import { useEffect, useMemo, useRef, useState } from 'react';
import {
  ChatMessage,
  ChatSession,
  ChatSessionWithMessages,
  createChatSession,
  getChatSession,
  listChatMessages,
  listChatSessions,
  postChatMessage,
  getProjectContext,
  putProjectContext,
} from '../lib/api';

interface ChatPanelProps {
  projectId: string;
  prefill?: string;
  onPrefillConsumed?: () => void;
  onRegenerateRequested?: () => void | Promise<void>;
  onAIGenerateRequested?: () => void | Promise<void>;
  autoGenerateDefault?: boolean;
}

export default function ChatPanel({ projectId, prefill, onPrefillConsumed, onRegenerateRequested, onAIGenerateRequested, autoGenerateDefault }: ChatPanelProps) {
  const [sessions, setSessions] = useState<ChatSession[]>([]);
  const [selected, setSelected] = useState<string | null>(null);
  const [current, setCurrent] = useState<ChatSessionWithMessages | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [sending, setSending] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [notice, setNotice] = useState<string | null>(null);
  const [draft, setDraft] = useState<string>('');
  const [titleDraft, setTitleDraft] = useState<string>('Refinement Chat');

  // Review/Approve state
  const [extracted, setExtracted] = useState<string[]>([]);
  const [selectedMap, setSelectedMap] = useState<Record<string, boolean>>({});
  const [syncing, setSyncing] = useState<boolean>(false);
  const [syncNotice, setSyncNotice] = useState<string | null>(null);
  const [generating, setGenerating] = useState<boolean>(false);
  const [autoGenerate, setAutoGenerate] = useState<boolean>(!!autoGenerateDefault);
  const [assistantTyping, setAssistantTyping] = useState<boolean>(false);
  const [generationStages, setGenerationStages] = useState<string[]>([]);
  const [generationProgress, setGenerationProgress] = useState<number>(0);
  const [toast, setToast] = useState<{ type: 'error' | 'info'; message: string; actionLabel?: string; action?: () => void } | null>(null);

  const bottomRef = useRef<HTMLDivElement | null>(null);
  const inputRef = useRef<HTMLTextAreaElement | null>(null);

  const pushGenerationStage = (label: string, progress?: number) => {
    setGenerationStages(prev => [...prev, label]);
    if (typeof progress === 'number') {
      setGenerationProgress(Math.max(0, Math.min(1, progress)));
    }
  };

  function autoResize() {
    const el = inputRef.current;
    if (!el) return;
    el.style.height = 'auto';
    const max = 200; // px
    el.style.height = Math.min(el.scrollHeight, max) + 'px';
  }

  async function ensureSession(): Promise<string> {
    // If a session is already selected, return it
    if (selected) return selected;
    // If sessions exist, pick the most recent
    if (sessions.length > 0) {
      const sid = sessions[0].session_id;
      setSelected(sid);
      return sid;
    }
    // Otherwise, create a new session
    const created = await createChatSession(projectId, titleDraft || 'Refinement Chat');
    await refreshSessions();
    setSelected(created.session_id);
    return created.session_id;
  }

  async function refreshSessions() {
    try {
      setError(null);
      const list = await listChatSessions(projectId);
      setSessions(list);
      if (list.length > 0 && !selected) {
        setSelected(list[0].session_id);
      }
    } catch (e: any) {
      setError(e?.message || String(e));
    }
  }

  async function applyAllFromChat() {
    const msgs = current?.messages || [];
    if (!msgs.length) {
      setSyncNotice('No messages in chat.');
      return;
    }
    // Extract SHALL from all messages (assistant + user) for convenience
    const allText = msgs.map(m => m.content).join('\n');
    const all = extractShallFromText(allText);
    if (all.length === 0) {
      setSyncNotice('No SHALL requirements detected in this chat.');
      return;
    }
    try {
      setSyncing(true);
      setSyncNotice(null);
      const ctx = await getProjectContext(projectId);
      const data: any = (ctx && ctx.data) ? { ...ctx.data } : {};
      const answers: Record<string, string[]> = Array.isArray(data.answers) ? {} : (data.answers || {});
      const currentReqs: string[] = Array.isArray(answers['Requirements']) ? answers['Requirements'] : [];
      const merged = currentReqs.slice();
      for (const r of all) if (!merged.includes(r)) merged.push(r);
      const payload = { data: { ...data, answers: { ...answers, Requirements: merged } } } as any;
      await putProjectContext(projectId, payload);
      setSyncNotice(`Applied ${all.length} requirement(s) to stored context.`);
    } catch (e: any) {
      setSyncNotice(e?.message || String(e));
    } finally {
      setSyncing(false);
    }
  }

  async function applyAllAndGenerate() {
    try {
      setGenerating(true);
      setSyncNotice('Applying requirements to Stored Context…');
      setGenerationStages([]);
      setGenerationProgress(0);
      pushGenerationStage('Applying requirements to Stored Context…', 0.25);
      setToast(null);
      await applyAllFromChat();
      // Stage: generating
      const stageLabel = onAIGenerateRequested ? 'Generating documents via AI…' : 'Regenerating documents…';
      setSyncNotice(stageLabel);
      pushGenerationStage(stageLabel, 0.65);
      // Await generation callback if it returns a promise
      if (onAIGenerateRequested) await Promise.resolve(onAIGenerateRequested());
      else if (onRegenerateRequested) await Promise.resolve(onRegenerateRequested());
      setSyncNotice('Generation complete.');
      pushGenerationStage('Generation complete.', 1);
    } catch (e: any) {
      setSyncNotice(e?.message || String(e));
      const msg = e?.message || 'Generation failed. Please try again.';
      pushGenerationStage(`Generation failed: ${msg}`);
      setGenerationProgress(0);
      setToast({
        type: 'error',
        message: msg,
        actionLabel: 'Retry',
        action: () => {
          setToast(null);
          applyAllAndGenerate();
        },
      });
    } finally {
      setGenerating(false);
      setTimeout(() => {
        setGenerationStages([]);
        setGenerationProgress(0);
      }, 4000);
    }
  }

  async function loadSession(session_id: string) {
    try {
      setLoading(true);
      setError(null);
      const s = await getChatSession(session_id);
      setCurrent(s);
      setSelected(session_id);
    } catch (e: any) {
      setError(e?.message || String(e));
    } finally {
      setLoading(false);
    }
  }

  async function onNewSession(e?: React.FormEvent) {
    if (e) e.preventDefault();
    try {
      setLoading(true);
      setError(null);
      const created = await createChatSession(projectId, titleDraft || undefined);
      setNotice('New chat started.');
      await refreshSessions();
      await loadSession(created.session_id);
    } catch (e: any) {
      setError(e?.message || String(e));
    } finally {
      setLoading(false);
    }
  }

  async function onSend(e?: React.FormEvent) {
    if (e) e.preventDefault();
    if (!draft.trim()) return;
    try {
      setSending(true);
      setAssistantTyping(true);
      setError(null);
      const sid = await ensureSession();
      // Optimistic append user message
      const now = new Date().toISOString();
      setCurrent(prev => prev ? {
        ...prev,
        messages: [...prev.messages, {
          message_id: 'local-' + Math.random().toString(36).slice(2),
          session_id: sid,
          role: 'user',
          content: draft.trim(),
          created_at: now,
        } as ChatMessage],
      } : prev);
      const assistant = await postChatMessage(sid, draft.trim());
      // Fetch full list to include the user message as persisted + assistant response
      const msgs = await listChatMessages(sid);
      setCurrent(prev => prev ? { ...prev, messages: msgs } : prev);
      setDraft('');
      setNotice('Assistant replied.');
      // scroll to bottom after sending
      requestAnimationFrame(() => bottomRef.current?.scrollIntoView({ behavior: 'smooth' }));
      // If auto mode is enabled, only apply & generate when conversation is READY
      if (autoGenerate && onRegenerateRequested) {
        try {
          const shalls = extractShallFromText(msgs.map(m => m.content).join('\n'));
          const ready = computeReadinessFromMessages(msgs as any, shalls).ready;
          if (ready) {
            await applyAllAndGenerate();
          } else {
            setSyncNotice('Auto-generate is ON, but more detail is needed before generating. Keep chatting to refine requirements.');
          }
        } catch {}
      }
    } catch (e: any) {
      setError(e?.message || String(e));
    } finally {
      setSending(false);
      setAssistantTyping(false);
    }
  }

  useEffect(() => {
    if (!projectId) return;
    refreshSessions();
  }, [projectId]);

  // Auto-ensure a session exists after sessions load, to remove friction for first-time users
  useEffect(() => {
    if (!projectId) return;
    if (!selected) {
      ensureSession().catch(() => {});
    }
  }, [projectId, sessions.length]);

  // Allow external components to prefill the chat input (e.g., scenario chips)
  useEffect(() => {
    if (!prefill) return;
    setDraft(prefill);
    onPrefillConsumed && onPrefillConsumed();
    requestAnimationFrame(autoResize);
  }, [prefill]);

  useEffect(() => {
    if (!selected) return;
    loadSession(selected);
  }, [selected]);

  useEffect(() => {
    // Auto-scroll when messages change
    requestAnimationFrame(() => bottomRef.current?.scrollIntoView({ behavior: 'smooth' }));
  }, [current?.messages?.length]);

  // Auto-extract candidate requirements whenever messages change
  useEffect(() => {
    const msgs = current?.messages || [];
    if (!msgs.length) {
      setExtracted([]);
      setSelectedMap({});
      return;
    }
    const texts = msgs.map(m => m.content);
    const found: string[] = [];
    for (const t of texts) found.push(...extractShallFromText(t));
    const seen = new Set<string>();
    const uniq: string[] = [];
    for (const r of found) { if (!seen.has(r)) { seen.add(r); uniq.push(r); } }
    setExtracted(uniq);
    const map: Record<string, boolean> = {};
    uniq.forEach(r => map[r] = true);
    setSelectedMap(map);
  }, [current?.messages?.length]);

  function extractShallFromText(text: string): string[] {
    const out: string[] = [];
    // Split into lines first, then sentences within lines
    const lines = text.split(/\r?\n/);
    for (let ln of lines) {
      const cleaned = ln.trim().replace(/^[-*•\d.\)\s]+/, '').trim();
      if (!cleaned) continue;
      const sentences = cleaned
        .split(/(?<=[.!?])\s+|\s*;\s+/) // end punctuation or semicolons
        .map(s => s.trim())
        .filter(Boolean);
      for (let s of sentences) {
        if (!s || s.length < 6) continue;
        // Skip meta lines
        if (/^(note|summary|context)[:\s]/i.test(s)) continue;
        let t = s;
        // If it already states SHALL, keep it
        if (!/\bshall\b/i.test(t)) {
          // If it indicates intent (should|must|will|enable|allow|support|provide), convert
          if (/(should|must|will|require|enable|allow|support|provide|include)\b/i.test(t)) {
            // fallthrough to convert
          }
          // Convert to canonical SHALL
          if (!/[.!?]$/.test(t)) t += '.';
          t = 'The system SHALL ' + t.charAt(0).toUpperCase() + t.slice(1);
        } else {
          // Ensure trailing punctuation
          if (!/[.!?]$/.test(t)) t += '.';
          // Normalize casing of leading phrase
          t = t.replace(/^the\s+system\s+shall/i, 'The system SHALL');
        }
        if (/^The system SHALL\s+/.test(t)) out.push(t);
      }
    }
    const seen = new Set<string>();
    const uniq: string[] = [];
    for (const r of out) if (!seen.has(r)) { seen.add(r); uniq.push(r); }
    return uniq;
  }

  function computeReadinessFromMessages(
    msgs: ChatMessage[],
    shalls: string[]
  ): { ready: boolean; reason: string; score: number; missing: string[] } {
    const userMsgs = (msgs || []).filter(m => m.role === 'user');
    const userCount = userMsgs.length;
    const totalChars = (msgs || []).reduce((n, m) => n + (m.content?.length || 0), 0);
    const allText = (msgs || []).map(m => m.content).join('\n');

    // Coverage heuristics
    const hasStakeholders = /(stakeholder|user(?:s)?|persona|customer|admin|operator)/i.test(allText);
    const hasScope = /(scope|objective|goal|outcome|success|kpi|metric)/i.test(allText);
    const hasNFR = /(nfr|non[- ]?functional|performance|latency|throughput|availability|reliability|security|compliance|gdpr|hipaa)/i.test(allText);
    const hasConstraints = /(constraint|assumption|risk|limitation|budget|timeline|deadline)/i.test(allText);
    const hasInterface = /(\bui\b|ux|screen|page|api|endpoint|integration|webhook)/i.test(allText);
    const hasTesting = /(test|qa|acceptance\s*criteria|traceability)/i.test(allText);
    const hasData = /(data\s*model|schema|database|storage|retention|index)/i.test(allText);

    // Q&A loop: assistant asked a question and user responded afterward
    let qaLoop = false;
    for (let i = msgs.length - 1; i >= 0; i--) {
      const m = msgs[i];
      if (m.role === 'assistant' && /\?/.test(m.content || '')) {
        qaLoop = msgs.slice(i + 1).some(x => x.role === 'user' && (x.content || '').trim().length >= 20);
        break;
      }
    }

    // Scoring
    let score = 0;
    const missing: string[] = [];
    // Clarity via SHALLs
    if (shalls.length >= 5) score += 25; else if (shalls.length >= 3) score += 20; else if (shalls.length >= 1) score += 10; else missing.push('clear requirements (SHALL)');
    // Coverage
    if (hasStakeholders) score += 15; else missing.push('stakeholders/users');
    if (hasScope) score += 15; else missing.push('scope/objectives');
    if (hasNFR) score += 10; else missing.push('NFRs (performance/security)');
    if (hasConstraints) score += 10; else missing.push('constraints/risks');
    if (hasInterface) score += 10; else missing.push('UI/API/integrations');
    if (hasTesting) score += 5; else missing.push('testing/acceptance');
    if (hasData) score += 5; else missing.push('data model/retention');
    // Conversation depth & detail
    if (userCount >= 2) score += 10;
    if (userCount >= 3) score += 10;
    if (totalChars >= 400) score += 10;
    // Q&A loop
    if (qaLoop) score += 10;

    if (score > 100) score = 100;
    // Encourage an actual back-and-forth: if no Q&A loop yet, cap readiness
    if (!qaLoop && score > 55) score = 55;
    const ready = score >= 60;
    const reason = ready ? `Ready (score ${score}).` : `Readiness ${score}%. Keep chatting to cover gaps.`;
    return { ready, reason, score, missing };
  }

  function quickPromptsFromMissing(missing: string[]): { key: string; label: string; prompt: string }[] {
    const map: Record<string, { label: string; prompt: string }> = {
      'stakeholders/users': { label: 'Stakeholders', prompt: 'Stakeholders: Who are the primary users or stakeholders and what are their goals?' },
      'scope/objectives': { label: 'Scope', prompt: 'Scope & Objectives: What is in scope for the first release and what outcomes define success?' },
      'NFRs (performance/security)': { label: 'NFRs', prompt: 'NFRs: Any performance targets (latency/throughput), availability, or security/compliance needs?' },
      'constraints/risks': { label: 'Constraints', prompt: 'Constraints & Risks: Any budget, timeline, technical constraints, assumptions, or known risks?' },
      'UI/API/integrations': { label: 'Interfaces', prompt: 'Interfaces: Which screens, APIs, integrations, or webhooks are expected?' },
      'testing/acceptance': { label: 'Testing', prompt: 'Testing: What acceptance criteria or test scenarios would confirm success?' },
      'data model/retention': { label: 'Data', prompt: 'Data: What data is involved, any schema/storage considerations, or retention policies?' },
      'clear requirements (SHALL)': { label: 'Requirements', prompt: 'Requirements: Can you provide 2–3 specific requirements? Example: "The system SHALL allow users to reset passwords via email."' },
    };
    const dedup: string[] = [];
    const out: { key: string; label: string; prompt: string }[] = [];
    for (const k of missing) {
      if (map[k] && !dedup.includes(k)) { dedup.push(k); out.push({ key: k, ...map[k] }); }
      if (out.length >= 4) break; // show up to 4 chips
    }
    return out;
  }

  function onExtract() {
    const msgs = current?.messages || [];
    const texts = msgs.map(m => m.content);
    const found: string[] = [];
    for (const t of texts) {
      found.push(...extractShallFromText(t));
    }
    const seen = new Set<string>();
    const uniq: string[] = [];
    for (const r of found) { if (!seen.has(r)) { seen.add(r); uniq.push(r); } }
    setExtracted(uniq);
    const map: Record<string, boolean> = {};
    uniq.forEach(r => map[r] = true);
    setSelectedMap(map);
    setSyncNotice(uniq.length ? `Found ${uniq.length} candidate requirements.` : 'No SHALL statements found in assistant messages.');
  }

  async function onApplySelectedToContext() {
    const selected = extracted.filter(r => selectedMap[r]);
    if (!selected.length) {
      setSyncNotice('Select at least one requirement to apply.');
      return;
    }
    try {
      setSyncing(true);
      setSyncNotice(null);
      // Fetch existing context
      const ctx = await getProjectContext(projectId);
      const data: any = (ctx && ctx.data) ? { ...ctx.data } : {};
      const answers: Record<string, string[]> = Array.isArray(data.answers) ? {} : (data.answers || {});
      const currentReqs: string[] = Array.isArray(answers['Requirements']) ? answers['Requirements'] : [];
      const merged = currentReqs.slice();
      for (const r of selected) {
        if (!merged.includes(r)) merged.push(r);
      }
      const payload = { data: { ...data, answers: { ...answers, Requirements: merged } } } as any;
      const saved = await putProjectContext(projectId, payload);
      setSyncNotice(`Applied ${selected.length} requirement(s) to stored context.`);
    } catch (e: any) {
      setSyncNotice(e?.message || String(e));
    } finally {
      setSyncing(false);
    }
  }

  const readyInfo = useMemo(() => {
    const msgs = current?.messages || [];
    const shalls = extractShallFromText(msgs.map(m => m.content).join('\n'));
    return computeReadinessFromMessages(msgs as any, shalls);
  }, [current?.messages?.length]);

  return (
    <div aria-label="Project Chat" role="region">
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: 8 }}>
        <div className="section-title">Chat</div>
        {notice && <span className="notice" aria-live="polite">{notice}</span>}
        {error && <span className="error" role="alert">{error}</span>}
      </div>

      {/* Session toolbar */}
      <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginBottom: 8, flexWrap: 'wrap' }}>
        <label style={{ display: 'inline-flex', alignItems: 'center', gap: 8 }}>
          <span className="muted">New Chat Title</span>
          <input className="input" value={titleDraft} onChange={e => setTitleDraft(e.target.value)} placeholder="Refinement Chat" />
        </label>
        <button className="btn" onClick={onNewSession} disabled={loading}>{loading ? 'Starting…' : 'Start New Chat'}</button>
        <select className="select" value={selected || ''} onChange={e => setSelected(e.target.value || null)} aria-label="Select chat session">
          <option value="" disabled>Choose a session…</option>
          {sessions.map(s => (
            <option key={s.session_id} value={s.session_id}>{s.title} — {new Date(s.updated_at).toLocaleString()}</option>
          ))}
        </select>
      </div>

      {/* Message list */}
      <div className="chat-box">
        {!current || (current.messages?.length || 0) === 0 ? (
          <div className="muted">No messages yet. Describe the issue or idea you are working on and send it to start refining.</div>
        ) : (
          <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>
            {current.messages.map(m => (
              <li key={m.message_id} className="msg-row" style={{ justifyContent: m.role === 'user' ? 'flex-end' : 'flex-start' }}>
                <div className={`msg ${m.role === 'user' ? 'msg-user' : 'msg-assistant'}`} aria-label={`${m.role} message`}>
                  {m.content}
                  <div className="msg-meta" style={{ textAlign: m.role === 'user' ? 'right' : 'left' }}>
                    {new Date(m.created_at).toLocaleTimeString()}
                  </div>
                </div>
              </li>
            ))}
            {assistantTyping && (
              <li className="msg-row" style={{ justifyContent: 'flex-start' }}>
                <div className="msg msg-assistant" aria-live="polite" aria-label="assistant typing">
                  <div className="typing-indicator" role="status">
                    <span className="typing-dots"><span /><span /><span /></span>
                    <span>Assistant is typing…</span>
                  </div>
                </div>
              </li>
            )}
            <div ref={bottomRef} />
          </ul>
        )}
      </div>

      {/* Input */}
      <form onSubmit={onSend} style={{ display: 'flex', gap: 8, alignItems: 'flex-end', marginTop: 8 }}>
        <textarea
          ref={inputRef}
          className="textarea chat-input"
          aria-label="Your message"
          placeholder="Describe your issue or idea… (Enter to send, Shift+Enter for newline)"
          value={draft}
          onChange={e => { setDraft(e.target.value); autoResize(); }}
          onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); onSend(); } }}
          onFocus={() => { if (!selected && !sending) ensureSession().catch(() => {}); }}
          style={{ flex: 1, resize: 'none' }}
        />
        <button className="btn btn-primary" type="submit" disabled={sending || !draft.trim()} aria-busy={sending}>{'Send'}</button>
      </form>

      {/* Review/Approve: Extract and apply to Stored Context */}
      <div style={{ borderTop: '1px solid var(--border)', marginTop: 12, paddingTop: 12 }}>
        {/* Readiness meter */}
        <div className="card" style={{ marginBottom: 8, padding: 8 }}>
          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
            <strong>Readiness to Generate</strong>
            <span className="muted">{Math.round(readyInfo.score || 0)}%</span>
          </div>
          <div aria-label="Readiness progress" style={{ height: 8, background: 'var(--border)', borderRadius: 4, overflow: 'hidden', marginTop: 6 }}>
            <div style={{ width: `${Math.max(0, Math.min(100, Math.round(readyInfo.score || 0)))}%`, height: '100%', background: 'var(--primary)', transition: 'width 0.3s ease' }} />
          </div>
          {!readyInfo.ready && (
            <div className="muted" style={{ marginTop: 6, fontSize: 12 }}>
              {readyInfo.reason} {Array.isArray(readyInfo.missing) && readyInfo.missing.length ? `Hint: add ${readyInfo.missing.slice(0,3).join(', ')}.` : ''}
            </div>
          )}
          {/* Quick prompts */}
          {Array.isArray(readyInfo.missing) && readyInfo.missing.length > 0 && (
            <div style={{ marginTop: 8, display: 'flex', gap: 6, flexWrap: 'wrap' }}>
              {quickPromptsFromMissing(readyInfo.missing).map(p => (
                <button
                  key={p.key}
                  type="button"
                  className="badge"
                  title={p.prompt}
                  onClick={() => { setDraft(prev => (prev && prev.trim()) ? (prev.trim() + "\n" + p.prompt) : p.prompt); requestAnimationFrame(() => inputRef.current?.focus()); }}
                >
                  + {p.label}
                </button>
              ))}
            </div>
          )}
        </div>
        <div className="sticky-actions" style={{ display: 'flex', gap: 8, alignItems: 'center', marginBottom: 8, flexWrap: 'wrap' }}>
          <strong>Review & Apply</strong>
          {onRegenerateRequested && (
            <button className="btn btn-primary" onClick={applyAllAndGenerate} disabled={generating || syncing || !readyInfo.ready} aria-busy={generating || undefined} title={readyInfo.ready ? undefined : readyInfo.reason}>
              {generating ? 'Applying & Generating…' : 'Apply & Generate'}
            </button>
          )}
          {generating && (
            <div style={{ display: 'inline-flex', alignItems: 'center', gap: 8 }} aria-live="polite">
              <progress aria-label="Generating documents" max={1} value={Math.max(0, Math.min(1, generationProgress))} />
              <span className="muted">Working on generation…</span>
            </div>
          )}
          {generationStages.length > 0 && (
            <ul className="generation-stages" aria-live="polite">
              {generationStages.map((stage, idx) => (
                <li key={`${stage}-${idx}`}>{stage}</li>
              ))}
            </ul>
          )}
          <label style={{ display: 'inline-flex', alignItems: 'center', gap: 6 }}>
            <input type="checkbox" checked={autoGenerate} onChange={e => setAutoGenerate(e.target.checked)} /> Auto-apply & generate (when ready)
          </label>
          <details>
            <summary style={{ cursor: 'pointer' }}>More</summary>
            <div style={{ display: 'flex', gap: 8, marginTop: 6, alignItems: 'center', flexWrap: 'wrap' }}>
              <button className="btn" onClick={onExtract} disabled={!current || (current.messages?.length || 0) === 0}>Extract suggestions</button>
              <button className="btn" onClick={applyAllFromChat} disabled={syncing || !current || (current.messages?.length || 0) === 0}>Apply all from chat</button>
              <button className="btn" onClick={onApplySelectedToContext} disabled={syncing || extracted.length === 0}>{syncing ? 'Applying…' : 'Apply selected to Stored Context'}</button>
            </div>
          </details>
          {syncNotice && <span className="muted">{syncNotice}</span>}
        </div>
        {extracted.length > 0 && (
          <div className="card" style={{ maxHeight: 160, overflowY: 'auto' }}>
            {extracted.map((r, i) => (
              <label key={i} style={{ display: 'flex', alignItems: 'flex-start', gap: 8, marginBottom: 6 }}>
                <input type="checkbox" checked={!!selectedMap[r]} onChange={e => setSelectedMap(prev => ({ ...prev, [r]: e.target.checked }))} />
                <span style={{ fontSize: 13 }}>{r}</span>
              </label>
            ))}
          </div>
        )}
        <div className="muted" style={{ marginTop: 6, fontSize: 12 }}>
          Tip: Review the assistant’s suggested SHALL requirements and apply only the ones you approve. You can regenerate documents afterward.
        </div>
      </div>
      <div className="muted" style={{ marginTop: 6, fontSize: 12 }}>
        Tip: You can start a new chat for a different refinement path. The assistant uses your project documents as context when available.
      </div>
    </div>
  );
}
