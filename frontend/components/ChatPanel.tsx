import { useEffect, useMemo, useRef, useState } from 'react';
import {
  ChatMessage,
  ChatSession,
  ChatSessionWithMessages,
  createChatSession,
  getChatSession,
  listChatMessages,
  listChatSessions,
  postChatMessage,
  getProjectContext,
  putProjectContext,
} from '../lib/api';

interface ChatPanelProps {
  projectId: string;
  prefill?: string;
  onPrefillConsumed?: () => void;
  onRegenerateRequested?: () => void | Promise<void>;
  onAIGenerateRequested?: () => void | Promise<void>;
  autoGenerateDefault?: boolean;
}

export default function ChatPanel({ projectId, prefill, onPrefillConsumed, onRegenerateRequested, onAIGenerateRequested, autoGenerateDefault }: ChatPanelProps) {
  const [sessions, setSessions] = useState<ChatSession[]>([]);
  const [selected, setSelected] = useState<string | null>(null);
  const [current, setCurrent] = useState<ChatSessionWithMessages | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [sending, setSending] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [notice, setNotice] = useState<string | null>(null);
  const [draft, setDraft] = useState<string>('');
  const [titleDraft, setTitleDraft] = useState<string>('Refinement Chat');

  // Review/Approve state
  const [extracted, setExtracted] = useState<string[]>([]);
  const [selectedMap, setSelectedMap] = useState<Record<string, boolean>>({});
  const [syncing, setSyncing] = useState<boolean>(false);
  const [syncNotice, setSyncNotice] = useState<string | null>(null);
  const [generating, setGenerating] = useState<boolean>(false);
  const [autoGenerate, setAutoGenerate] = useState<boolean>(!!autoGenerateDefault);

  const bottomRef = useRef<HTMLDivElement | null>(null);
  const inputRef = useRef<HTMLTextAreaElement | null>(null);

  function autoResize() {
    const el = inputRef.current;
    if (!el) return;
    el.style.height = 'auto';
    const max = 200; // px
    el.style.height = Math.min(el.scrollHeight, max) + 'px';
  }

  async function ensureSession(): Promise<string> {
    // If a session is already selected, return it
    if (selected) return selected;
    // If sessions exist, pick the most recent
    if (sessions.length > 0) {
      const sid = sessions[0].session_id;
      setSelected(sid);
      return sid;
    }
    // Otherwise, create a new session
    const created = await createChatSession(projectId, titleDraft || 'Refinement Chat');
    await refreshSessions();
    setSelected(created.session_id);
    return created.session_id;
  }

  async function refreshSessions() {
    try {
      setError(null);
      const list = await listChatSessions(projectId);
      setSessions(list);
      if (list.length > 0 && !selected) {
        setSelected(list[0].session_id);
      }
    } catch (e: any) {
      setError(e?.message || String(e));
    }
  }

  async function applyAllFromChat() {
    const msgs = current?.messages || [];
    if (!msgs.length) {
      setSyncNotice('No messages in chat.');
      return;
    }
    // Extract SHALL from all messages (assistant + user) for convenience
    const allText = msgs.map(m => m.content).join('\n');
    const all = extractShallFromText(allText);
    if (all.length === 0) {
      setSyncNotice('No SHALL requirements detected in this chat.');
      return;
    }
    try {
      setSyncing(true);
      setSyncNotice(null);
      const ctx = await getProjectContext(projectId);
      const data: any = (ctx && ctx.data) ? { ...ctx.data } : {};
      const answers: Record<string, string[]> = Array.isArray(data.answers) ? {} : (data.answers || {});
      const currentReqs: string[] = Array.isArray(answers['Requirements']) ? answers['Requirements'] : [];
      const merged = currentReqs.slice();
      for (const r of all) if (!merged.includes(r)) merged.push(r);
      const payload = { data: { ...data, answers: { ...answers, Requirements: merged } } } as any;
      await putProjectContext(projectId, payload);
      setSyncNotice(`Applied ${all.length} requirement(s) to stored context.`);
    } catch (e: any) {
      setSyncNotice(e?.message || String(e));
    } finally {
      setSyncing(false);
    }
  }

  async function applyAllAndGenerate() {
    try {
      setGenerating(true);
      setSyncNotice(null);
      await applyAllFromChat();
      // Await generation callback if it returns a promise
      if (onAIGenerateRequested) await Promise.resolve(onAIGenerateRequested());
      else if (onRegenerateRequested) await Promise.resolve(onRegenerateRequested());
      setSyncNotice('Regenerating documents…');
    } catch (e: any) {
      setSyncNotice(e?.message || String(e));
    } finally {
      setGenerating(false);
    }
  }

  async function loadSession(session_id: string) {
    try {
      setLoading(true);
      setError(null);
      const s = await getChatSession(session_id);
      setCurrent(s);
      setSelected(session_id);
    } catch (e: any) {
      setError(e?.message || String(e));
    } finally {
      setLoading(false);
    }
  }

  async function onNewSession(e?: React.FormEvent) {
    if (e) e.preventDefault();
    try {
      setLoading(true);
      setError(null);
      const created = await createChatSession(projectId, titleDraft || undefined);
      setNotice('New chat started.');
      await refreshSessions();
      await loadSession(created.session_id);
    } catch (e: any) {
      setError(e?.message || String(e));
    } finally {
      setLoading(false);
    }
  }

  async function onSend(e?: React.FormEvent) {
    if (e) e.preventDefault();
    if (!draft.trim()) return;
    try {
      setSending(true);
      setError(null);
      const sid = await ensureSession();
      // Optimistic append user message
      const now = new Date().toISOString();
      setCurrent(prev => prev ? {
        ...prev,
        messages: [...prev.messages, {
          message_id: 'local-' + Math.random().toString(36).slice(2),
          session_id: sid,
          role: 'user',
          content: draft.trim(),
          created_at: now,
        } as ChatMessage],
      } : prev);
      const assistant = await postChatMessage(sid, draft.trim());
      // Fetch full list to include the user message as persisted + assistant response
      const msgs = await listChatMessages(sid);
      setCurrent(prev => prev ? { ...prev, messages: msgs } : prev);
      setDraft('');
      setNotice('Assistant replied.');
      // scroll to bottom after sending
      requestAnimationFrame(() => bottomRef.current?.scrollIntoView({ behavior: 'smooth' }));
      // If auto mode is enabled, immediately apply & generate
      if (autoGenerate && onRegenerateRequested) {
        try { await applyAllAndGenerate(); } catch {}
      }
    } catch (e: any) {
      setError(e?.message || String(e));
    } finally {
      setSending(false);
    }
  }

  useEffect(() => {
    if (!projectId) return;
    refreshSessions();
  }, [projectId]);

  // Auto-ensure a session exists after sessions load, to remove friction for first-time users
  useEffect(() => {
    if (!projectId) return;
    if (!selected) {
      ensureSession().catch(() => {});
    }
  }, [projectId, sessions.length]);

  // Allow external components to prefill the chat input (e.g., scenario chips)
  useEffect(() => {
    if (!prefill) return;
    setDraft(prefill);
    onPrefillConsumed && onPrefillConsumed();
    requestAnimationFrame(autoResize);
  }, [prefill]);

  useEffect(() => {
    if (!selected) return;
    loadSession(selected);
  }, [selected]);

  useEffect(() => {
    // Auto-scroll when messages change
    requestAnimationFrame(() => bottomRef.current?.scrollIntoView({ behavior: 'smooth' }));
  }, [current?.messages?.length]);

  // Auto-extract candidate requirements whenever messages change
  useEffect(() => {
    const msgs = current?.messages || [];
    if (!msgs.length) {
      setExtracted([]);
      setSelectedMap({});
      return;
    }
    const texts = msgs.map(m => m.content);
    const found: string[] = [];
    for (const t of texts) found.push(...extractShallFromText(t));
    const seen = new Set<string>();
    const uniq: string[] = [];
    for (const r of found) { if (!seen.has(r)) { seen.add(r); uniq.push(r); } }
    setExtracted(uniq);
    const map: Record<string, boolean> = {};
    uniq.forEach(r => map[r] = true);
    setSelectedMap(map);
  }, [current?.messages?.length]);

  function extractShallFromText(text: string): string[] {
    const out: string[] = [];
    // Split into lines first, then sentences within lines
    const lines = text.split(/\r?\n/);
    for (let ln of lines) {
      const cleaned = ln.trim().replace(/^[-*•\d.\)\s]+/, '').trim();
      if (!cleaned) continue;
      const sentences = cleaned
        .split(/(?<=[.!?])\s+|\s*;\s+/) // end punctuation or semicolons
        .map(s => s.trim())
        .filter(Boolean);
      for (let s of sentences) {
        if (!s || s.length < 6) continue;
        // Skip meta lines
        if (/^(note|summary|context)[:\s]/i.test(s)) continue;
        let t = s;
        // If it already states SHALL, keep it
        if (!/\bshall\b/i.test(t)) {
          // If it indicates intent (should|must|will|enable|allow|support|provide), convert
          if (/(should|must|will|require|enable|allow|support|provide|include)\b/i.test(t)) {
            // fallthrough to convert
          }
          // Convert to canonical SHALL
          if (!/[.!?]$/.test(t)) t += '.';
          t = 'The system SHALL ' + t.charAt(0).toUpperCase() + t.slice(1);
        } else {
          // Ensure trailing punctuation
          if (!/[.!?]$/.test(t)) t += '.';
          // Normalize casing of leading phrase
          t = t.replace(/^the\s+system\s+shall/i, 'The system SHALL');
        }
        if (/^The system SHALL\s+/.test(t)) out.push(t);
      }
    }
    const seen = new Set<string>();
    const uniq: string[] = [];
    for (const r of out) if (!seen.has(r)) { seen.add(r); uniq.push(r); }
    return uniq;
  }

  function onExtract() {
    const msgs = current?.messages || [];
    const texts = msgs.map(m => m.content);
    const found: string[] = [];
    for (const t of texts) {
      found.push(...extractShallFromText(t));
    }
    const seen = new Set<string>();
    const uniq: string[] = [];
    for (const r of found) { if (!seen.has(r)) { seen.add(r); uniq.push(r); } }
    setExtracted(uniq);
    const map: Record<string, boolean> = {};
    uniq.forEach(r => map[r] = true);
    setSelectedMap(map);
    setSyncNotice(uniq.length ? `Found ${uniq.length} candidate requirements.` : 'No SHALL statements found in assistant messages.');
  }

  async function onApplySelectedToContext() {
    const selected = extracted.filter(r => selectedMap[r]);
    if (!selected.length) {
      setSyncNotice('Select at least one requirement to apply.');
      return;
    }
    try {
      setSyncing(true);
      setSyncNotice(null);
      // Fetch existing context
      const ctx = await getProjectContext(projectId);
      const data: any = (ctx && ctx.data) ? { ...ctx.data } : {};
      const answers: Record<string, string[]> = Array.isArray(data.answers) ? {} : (data.answers || {});
      const currentReqs: string[] = Array.isArray(answers['Requirements']) ? answers['Requirements'] : [];
      const merged = currentReqs.slice();
      for (const r of selected) {
        if (!merged.includes(r)) merged.push(r);
      }
      const payload = { data: { ...data, answers: { ...answers, Requirements: merged } } } as any;
      const saved = await putProjectContext(projectId, payload);
      setSyncNotice(`Applied ${selected.length} requirement(s) to stored context.`);
    } catch (e: any) {
      setSyncNotice(e?.message || String(e));
    } finally {
      setSyncing(false);
    }
  }

  return (
    <div aria-label="Project Chat" role="region">
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: 8 }}>
        <div className="section-title">Chat</div>
        {notice && <span className="notice">{notice}</span>}
        {error && <span className="error">{error}</span>}
      </div>

      {/* Session toolbar */}
      <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginBottom: 8, flexWrap: 'wrap' }}>
        <label style={{ display: 'inline-flex', alignItems: 'center', gap: 8 }}>
          <span className="muted">New Chat Title</span>
          <input className="input" value={titleDraft} onChange={e => setTitleDraft(e.target.value)} placeholder="Refinement Chat" />
        </label>
        <button className="btn" onClick={onNewSession} disabled={loading}>{loading ? 'Starting…' : 'Start New Chat'}</button>
        <select className="select" value={selected || ''} onChange={e => setSelected(e.target.value || null)} aria-label="Select chat session">
          <option value="" disabled>Choose a session…</option>
          {sessions.map(s => (
            <option key={s.session_id} value={s.session_id}>{s.title} — {new Date(s.updated_at).toLocaleString()}</option>
          ))}
        </select>
      </div>

      {/* Message list */}
      <div className="chat-box">
        {!current || (current.messages?.length || 0) === 0 ? (
          <div className="muted">No messages yet. Describe the issue or idea you are working on and send it to start refining.</div>
        ) : (
          <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>
            {current.messages.map(m => (
              <li key={m.message_id} className="msg-row" style={{ justifyContent: m.role === 'user' ? 'flex-end' : 'flex-start' }}>
                <div className={`msg ${m.role === 'user' ? 'msg-user' : 'msg-assistant'}`} aria-label={`${m.role} message`}>
                  {m.content}
                  <div className="msg-meta" style={{ textAlign: m.role === 'user' ? 'right' : 'left' }}>
                    {new Date(m.created_at).toLocaleTimeString()}
                  </div>
                </div>
              </li>
            ))}
            <div ref={bottomRef} />
          </ul>
        )}
      </div>

      {/* Input */}
      <form onSubmit={onSend} style={{ display: 'flex', gap: 8, alignItems: 'flex-end', marginTop: 8 }}>
        <textarea
          ref={inputRef}
          className="textarea chat-input"
          aria-label="Your message"
          placeholder="Describe your issue or idea… (Enter to send, Shift+Enter for newline)"
          value={draft}
          onChange={e => { setDraft(e.target.value); autoResize(); }}
          onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); onSend(); } }}
          onFocus={() => { if (!selected && !sending) ensureSession().catch(() => {}); }}
          style={{ flex: 1, resize: 'none' }}
        />
        <button className="btn btn-primary" type="submit" disabled={sending || !draft.trim()}>{sending ? 'Sending…' : 'Send'}</button>
      </form>

      {/* Review/Approve: Extract and apply to Stored Context */}
      <div style={{ borderTop: '1px solid var(--border)', marginTop: 12, paddingTop: 12 }}>
        <div className="sticky-actions" style={{ display: 'flex', gap: 8, alignItems: 'center', marginBottom: 8, flexWrap: 'wrap' }}>
          <strong>Review & Apply</strong>
          {onRegenerateRequested && (
            <button className="btn btn-primary" onClick={applyAllAndGenerate} disabled={generating || syncing} aria-busy={generating || undefined}>
              {generating ? 'Applying & Generating…' : 'Apply & Generate'}
            </button>
          )}
          <label style={{ display: 'inline-flex', alignItems: 'center', gap: 6 }}>
            <input type="checkbox" checked={autoGenerate} onChange={e => setAutoGenerate(e.target.checked)} /> Auto-apply & generate
          </label>
          <details>
            <summary style={{ cursor: 'pointer' }}>More</summary>
            <div style={{ display: 'flex', gap: 8, marginTop: 6, alignItems: 'center', flexWrap: 'wrap' }}>
              <button className="btn" onClick={onExtract} disabled={!current || (current.messages?.length || 0) === 0}>Extract suggestions</button>
              <button className="btn" onClick={applyAllFromChat} disabled={syncing || !current || (current.messages?.length || 0) === 0}>Apply all from chat</button>
              <button className="btn" onClick={onApplySelectedToContext} disabled={syncing || extracted.length === 0}>{syncing ? 'Applying…' : 'Apply selected to Stored Context'}</button>
            </div>
          </details>
          {syncNotice && <span className="muted">{syncNotice}</span>}
        </div>
        {extracted.length > 0 && (
          <div className="card" style={{ maxHeight: 160, overflowY: 'auto' }}>
            {extracted.map((r, i) => (
              <label key={i} style={{ display: 'flex', alignItems: 'flex-start', gap: 8, marginBottom: 6 }}>
                <input type="checkbox" checked={!!selectedMap[r]} onChange={e => setSelectedMap(prev => ({ ...prev, [r]: e.target.checked }))} />
                <span style={{ fontSize: 13 }}>{r}</span>
              </label>
            ))}
          </div>
        )}
        <div className="muted" style={{ marginTop: 6, fontSize: 12 }}>
          Tip: Review the assistant’s suggested SHALL requirements and apply only the ones you approve. You can regenerate documents afterward.
        </div>
      </div>
      <div className="muted" style={{ marginTop: 6, fontSize: 12 }}>
        Tip: You can start a new chat for a different refinement path. The assistant uses your project documents as context when available.
      </div>
    </div>
  );
}
