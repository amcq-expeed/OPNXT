import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  CatalogIntent,
  ChatMessage,
  ChatModelOption,
  ChatSession,
  ChatSessionWithMessages,
  ChatTemplate,
  ChatSearchHit,
  createChatSession,
  formatCatalogIntentPrompt,
  getChatSession,
  getProjectContext,
  listCatalogIntents,
  listChatMessages,
  listChatModels,
  listChatSessions,
  listChatTemplates,
  postChatMessage,
  putProjectContext,
  searchChatMessages,
  trackEvent,
} from "../lib/api";
import { useUserContext } from "../lib/user-context";
import {
  getModelPreference,
  setModelPreference,
} from "../lib/modelPreference";

interface ChatPanelProps {
  projectId: string;
  prefill?: string;
  onPrefillConsumed?: () => void;
  onRegenerateRequested?: () => void | Promise<void>;
  onAIGenerateRequested?: () => void | Promise<void>;
  autoGenerateDefault?: boolean;
}

export default function ChatPanel({
  projectId,
  prefill,
  onPrefillConsumed,
  onRegenerateRequested,
  onAIGenerateRequested,
  autoGenerateDefault,
}: ChatPanelProps) {
  const { persona } = useUserContext();
  const [sessions, setSessions] = useState<ChatSession[]>([]);
  const [selected, setSelected] = useState<string | null>(null);
  const [current, setCurrent] = useState<ChatSessionWithMessages | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [sending, setSending] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [notice, setNotice] = useState<string | null>(null);
  const [draft, setDraft] = useState<string>("");
  const [titleDraft, setTitleDraft] = useState<string>("Refinement Chat");

  // Review/Approve state
  const [extracted, setExtracted] = useState<string[]>([]);
  const [selectedMap, setSelectedMap] = useState<Record<string, boolean>>({});
  const [syncing, setSyncing] = useState<boolean>(false);
  const [syncNotice, setSyncNotice] = useState<string | null>(null);
  const [generating, setGenerating] = useState<boolean>(false);
  const [autoGenerate, setAutoGenerate] =
    useState<boolean>(!!autoGenerateDefault);
  const [assistantTyping, setAssistantTyping] = useState<boolean>(false);
  const [generationStages, setGenerationStages] = useState<string[]>([]);
  const [generationProgress, setGenerationProgress] = useState<number>(0);
  const [toast, setToast] = useState<{
    type: "error" | "info";
    message: string;
    actionLabel?: string;
    action?: () => void;
  } | null>(null);
  const [controlsOpen, setControlsOpen] = useState<boolean>(false);
  const [toolsOpen, setToolsOpen] = useState<boolean>(false);
  const [capabilitiesOpen, setCapabilitiesOpen] = useState<boolean>(false);
  const [catalogIntents, setCatalogIntents] = useState<CatalogIntent[]>([]);
  const [catalogLoading, setCatalogLoading] = useState<boolean>(false);
  const [catalogError, setCatalogError] = useState<string | null>(null);
  const [models, setModels] = useState<ChatModelOption[]>([]);
  const [modelLoading, setModelLoading] = useState<boolean>(false);
  const [modelError, setModelError] = useState<string | null>(null);
  const [selectedModel, setSelectedModel] = useState<string>("adaptive:auto");
  const [templates, setTemplates] = useState<ChatTemplate[]>([]);
  const [templatesLoading, setTemplatesLoading] = useState<boolean>(false);
  const [templatesError, setTemplatesError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState<string>("");
  const [searching, setSearching] = useState<boolean>(false);
  const [searchResults, setSearchResults] = useState<ChatSearchHit[]>([]);
  const [searchError, setSearchError] = useState<string | null>(null);

  const bottomRef = useRef<HTMLDivElement | null>(null);
  const inputRef = useRef<HTMLTextAreaElement | null>(null);
  const toolsInitialized = useRef<boolean>(false);

  const serializeModelKey = (opt: ChatModelOption) => `${opt.provider}:${opt.model}`;

  const pushGenerationStage = (label: string, progress?: number) => {
    setGenerationStages((prev) => [...prev, label]);
    if (typeof progress === "number") {
      setGenerationProgress(Math.max(0, Math.min(1, progress)));
    }
  };

  function autoResize() {
    const el = inputRef.current;
    if (!el) return;
    el.style.height = "auto";
    const max = 200; // px
    el.style.height = Math.min(el.scrollHeight, max) + "px";
  }

  const refreshSessions = useCallback(async () => {
    if (!projectId) return;
    try {
      setError(null);
      const list = await listChatSessions(projectId);
      setSessions(list);
      setSelected((prev) => {
        if (!list.length) return null;
        if (prev && list.some((item) => item.session_id === prev)) {
          return prev;
        }
        return list[0].session_id;
      });
    } catch (e: any) {
      setError(e?.message || String(e));
    }
  }, [projectId]);

  const ensureSession = useCallback(async (): Promise<string> => {
    if (selected) return selected;
    if (sessions.length > 0) {
      const sid = sessions[0].session_id;
      setSelected(sid);
      return sid;
    }
    if (!projectId) {
      throw new Error("projectId is required to create a chat session");
    }
    const created = await createChatSession(projectId, titleDraft || "Refinement Chat");
    await refreshSessions();
    setSelected(created.session_id);
    return created.session_id;
  }, [selected, sessions, projectId, titleDraft, refreshSessions]);

  function onTemplateSelect(template: ChatTemplate) {
    if (!template) return;
    setDraft((prev) =>
      prev && prev.trim() ? `${prev.trim()}

${template.prompt}` : template.prompt,
    );
    trackEvent("chat_template_selected", {
      templateId: template.template_id,
      title: template.title,
    });
    setCapabilitiesOpen(true);
    requestAnimationFrame(autoResize);
    requestAnimationFrame(() => inputRef.current?.focus());
  }

  async function applyAllFromChat() {
    const msgs = current?.messages || [];
    if (!msgs.length) {
      setSyncNotice("No messages in chat.");
      return;
    }
    // Extract SHALL from all messages (assistant + user) for convenience
    const allText = msgs.map((m) => m.content).join("\n");
    const all = extractShallFromText(allText);
    if (all.length === 0) {
      setSyncNotice("No SHALL requirements detected in this chat.");
      return;
    }
    try {
      setSyncing(true);
      setSyncNotice(null);
      const ctx = await getProjectContext(projectId);
      const data: any = ctx && ctx.data ? { ...ctx.data } : {};
      const answers: Record<string, string[]> = Array.isArray(data.answers)
        ? {}
        : data.answers || {};
      const currentReqs: string[] = Array.isArray(answers["Requirements"])
        ? answers["Requirements"]
        : [];
      const merged = currentReqs.slice();
      for (const r of all) if (!merged.includes(r)) merged.push(r);
      const payload = {
        data: { ...data, answers: { ...answers, Requirements: merged } },
      } as any;
      await putProjectContext(projectId, payload);
      setSyncNotice(`Applied ${all.length} requirement(s) to stored context.`);
    } catch (e: any) {
      setSyncNotice(e?.message || String(e));
    } finally {
      setSyncing(false);
    }
  }

  async function applyAllAndGenerate() {
    try {
      setGenerating(true);
      setSyncNotice("Applying requirements to Stored Context…");
      setGenerationStages([]);
      setGenerationProgress(0);
      pushGenerationStage("Applying requirements to Stored Context…", 0.25);
      setToast(null);
      await applyAllFromChat();
      // Stage: generating
      const stageLabel = onAIGenerateRequested
        ? "Generating documents via AI…"
        : "Regenerating documents…";
      setSyncNotice(stageLabel);
      pushGenerationStage(stageLabel, 0.65);
      // Await generation callback if it returns a promise
      if (onAIGenerateRequested) await Promise.resolve(onAIGenerateRequested());
      else if (onRegenerateRequested)
        await Promise.resolve(onRegenerateRequested());
      setSyncNotice("Generation complete.");
      pushGenerationStage("Generation complete.", 1);
    } catch (e: any) {
      setSyncNotice(e?.message || String(e));
      const msg = e?.message || "Generation failed. Please try again.";
      pushGenerationStage(`Generation failed: ${msg}`);
      setGenerationProgress(0);
      setToast({
        type: "error",
        message: msg,
        actionLabel: "Retry",
        action: () => {
          setToast(null);
          applyAllAndGenerate();
        },
      });
    } finally {
      setGenerating(false);
      setTimeout(() => {
        setGenerationStages([]);
        setGenerationProgress(0);
      }, 4000);
    }
  }

  async function loadSession(session_id: string) {
    try {
      setLoading(true);
      setError(null);
      const s = await getChatSession(session_id);
      setCurrent(s);
      setSelected(session_id);
    } catch (e: any) {
      setError(e?.message || String(e));
    } finally {
      setLoading(false);
    }
  }

  async function onNewSession(e?: React.FormEvent) {
    if (e) e.preventDefault();
    try {
      setLoading(true);
      setError(null);
      const created = await createChatSession(
        projectId,
        titleDraft || undefined,
      );
      setNotice("New chat started.");
      await refreshSessions();
      await loadSession(created.session_id);
    } catch (e: any) {
      setError(e?.message || String(e));
    } finally {
      setLoading(false);
    }
  }

  async function onSend(e?: React.FormEvent) {
    if (e) e.preventDefault();
    if (!draft.trim()) return;
    try {
      setSending(true);
      setAssistantTyping(true);
      setError(null);
      const sid = await ensureSession();
      // Optimistic append user message
      const now = new Date().toISOString();
      setCurrent((prev) =>
        prev
          ? {
              ...prev,
              messages: [
                ...prev.messages,
                {
                  message_id: "local-" + Math.random().toString(36).slice(2),
                  session_id: sid,
                  role: "user",
                  content: draft.trim(),
                  created_at: now,
                } as ChatMessage,
              ],
            }
          : prev,
      );
      const [providerOverride, modelOverride] = (() => {
        if (!selectedModel) return [null, null];
        const [provider, ...rest] = selectedModel.split(":");
        const model = rest.join(":") || null;
        if (!provider || provider === "adaptive") {
          return [null, null];
        }
        return [provider, model];
      })();
      const assistant = await postChatMessage(sid, draft.trim(), {
        provider: providerOverride,
        model: modelOverride,
      });
      // Fetch full list to include the user message as persisted + assistant response
      const msgs = await listChatMessages(sid);
      setCurrent((prev) => (prev ? { ...prev, messages: msgs } : prev));
      setDraft("");
      setNotice("Assistant replied.");
      // scroll to bottom after sending
      requestAnimationFrame(() =>
        bottomRef.current?.scrollIntoView({ behavior: "smooth" }),
      );
      // If auto mode is enabled, only apply & generate when conversation is READY
      if (autoGenerate && onRegenerateRequested) {
        try {
          const shalls = extractShallFromText(
            msgs.map((m) => m.content).join("\n"),
          );
          const ready = computeReadinessFromMessages(msgs as any, shalls).ready;
          if (ready) {
            await applyAllAndGenerate();
          } else {
            setSyncNotice(
              "Auto-generate is ON, but more detail is needed before generating. Keep chatting to refine requirements.",
            );
          }
        } catch {}
      }
    } catch (e: any) {
      setError(e?.message || String(e));
    } finally {
      setSending(false);
      setAssistantTyping(false);
    }
  }

  async function runSearch(e?: React.FormEvent) {
    if (e) e.preventDefault();
    const term = searchQuery.trim();
    if (term.length < 2) {
      setSearchError("Enter at least 2 characters.");
      setSearchResults([]);
      return;
    }
    try {
      setSearching(true);
      setSearchError(null);
      const hits = await searchChatMessages(term, projectId, 20);
      setSearchResults(hits ?? []);
      if (hits && hits.length > 0) {
        setCapabilitiesOpen(true);
      }
    } catch (err: any) {
      setSearchError(err?.message || String(err));
      setSearchResults([]);
    } finally {
      setSearching(false);
    }
  }

  useEffect(() => {
    if (!projectId) return;
    refreshSessions();
  }, [projectId, refreshSessions]);

  // Auto-ensure a session exists after sessions load, to remove friction for first-time users
  useEffect(() => {
    if (!projectId || selected) return;
    ensureSession().catch(() => {});
  }, [projectId, selected, ensureSession]);

  // Allow external components to prefill the chat input (e.g., scenario chips)
  useEffect(() => {
    if (!prefill) return;
    setDraft(prefill);
    onPrefillConsumed && onPrefillConsumed();
    requestAnimationFrame(autoResize);
  }, [prefill, onPrefillConsumed]);

  useEffect(() => {
    if (!projectId) return;
    let cancelled = false;
    setModelLoading(true);
    setModelError(null);
    listChatModels()
      .then((options) => {
        if (cancelled) return;
        const filtered = Array.isArray(options)
          ? options.filter((opt) => !opt.provider.startsWith("search"))
          : [];
        setModels(filtered);
        const persisted = getModelPreference();
        if (persisted) {
          const match = filtered.find(
            (opt) =>
              opt.provider === persisted.provider &&
              opt.model === persisted.model,
          );
          if (match) {
            setSelectedModel(serializeModelKey(match));
          } else if (persisted.provider === "adaptive") {
            setSelectedModel("adaptive:auto");
          }
        } else if (filtered.length > 0) {
          setSelectedModel(serializeModelKey(filtered[0]));
        }
      })
      .catch((error: any) => {
        if (cancelled) return;
        setModelError(error?.message || "Unable to load model catalog right now.");
      })
      .finally(() => {
        if (!cancelled) setModelLoading(false);
      });
    return () => {
      cancelled = true;
    };
  }, [projectId]);

  useEffect(() => {
    if (!projectId) return;
    let cancelled = false;
    setCatalogLoading(true);
    setCatalogError(null);
    listCatalogIntents(persona || undefined)
      .then((items) => {
        if (cancelled) return;
        setCatalogIntents(items ?? []);
      })
      .catch((error: any) => {
        if (cancelled) return;
        setCatalogError(error?.message || "Unable to load intent recipes right now.");
      })
      .finally(() => {
        if (!cancelled) setCatalogLoading(false);
      });
    return () => {
        cancelled = true;
    };
  }, [projectId, persona]);

  useEffect(() => {
    let cancelled = false;
    setTemplatesLoading(true);
    setTemplatesError(null);
    listChatTemplates()
      .then((items) => {
        if (cancelled) return;
        setTemplates(items ?? []);
      })
      .catch((error: any) => {
        if (cancelled) return;
        setTemplatesError(error?.message || "Unable to load chat templates right now.");
      })
      .finally(() => {
        if (!cancelled) setTemplatesLoading(false);
      });
    return () => {
      cancelled = true;
    };
  }, [projectId]);

  useEffect(() => {
    if (!selected) return;
    loadSession(selected);
  }, [selected]);

  useEffect(() => {
    // Auto-scroll when messages change
    requestAnimationFrame(() =>
      bottomRef.current?.scrollIntoView({ behavior: "smooth" }),
    );
  }, [current?.messages]);

  // Auto-extract candidate requirements whenever messages change
  useEffect(() => {
    const msgs = current?.messages || [];
    if (!msgs.length) {
      setExtracted([]);
      setSelectedMap({});
      return;
    }
    const texts = msgs.map((m) => m.content);
    const found: string[] = [];
    for (const t of texts) found.push(...extractShallFromText(t));
    const seen = new Set<string>();
    const uniq: string[] = [];
    for (const r of found) {
      if (!seen.has(r)) {
        seen.add(r);
        uniq.push(r);
      }
    }
    setExtracted(uniq);
    const map: Record<string, boolean> = {};
    uniq.forEach((r) => (map[r] = true));
    setSelectedMap(map);
  }, [current?.messages]);

  function extractShallFromText(text: string): string[] {
    const out: string[] = [];
    // Split into lines first, then sentences within lines
    const lines = text.split(/\r?\n/);
    for (let ln of lines) {
      const cleaned = ln
        .trim()
        .replace(/^[-*•\d.\)\s]+/, "")
        .trim();
      if (!cleaned) continue;
      const sentences = cleaned
        .split(/(?<=[.!?])\s+|\s*;\s+/) // end punctuation or semicolons
        .map((s) => s.trim())
        .filter(Boolean);
      for (let s of sentences) {
        if (!s || s.length < 6) continue;
        // Skip meta lines
        if (/^(note|summary|context)[:\s]/i.test(s)) continue;
        let t = s;
        // If it already states SHALL, keep it
        if (!/\bshall\b/i.test(t)) {
          // If it indicates intent (should|must|will|enable|allow|support|provide), convert
          if (
            /(should|must|will|require|enable|allow|support|provide|include)\b/i.test(
              t,
            )
          ) {
            // fallthrough to convert
          }
          // Convert to canonical SHALL
          if (!/[.!?]$/.test(t)) t += ".";
          t = "The system SHALL " + t.charAt(0).toUpperCase() + t.slice(1);
        } else {
          // Ensure trailing punctuation
          if (!/[.!?]$/.test(t)) t += ".";
          // Normalize casing of leading phrase
          t = t.replace(/^the\s+system\s+shall/i, "The system SHALL");
        }
        if (/^The system SHALL\s+/.test(t)) out.push(t);
      }
    }
    const seen = new Set<string>();
    const uniq: string[] = [];
    for (const r of out)
      if (!seen.has(r)) {
        seen.add(r);
        uniq.push(r);
      }
    return uniq;
  }

  function computeReadinessFromMessages(
    msgs: ChatMessage[],
    shalls: string[],
  ): { ready: boolean; reason: string; score: number; missing: string[] } {
    const userMsgs = (msgs || []).filter((m) => m.role === "user");
    const userCount = userMsgs.length;
    const substantiveUserReplies = userMsgs.filter(
      (m) => (m.content || "").trim().length >= 20,
    ).length;
    const totalChars = (msgs || []).reduce(
      (n, m) => n + (m.content?.length || 0),
      0,
    );
    const allText = (msgs || []).map((m) => m.content).join("\n");

    // Coverage heuristics
    const hasStakeholders =
      /(stakeholder|user(?:s)?|persona|customer|admin|operator)/i.test(allText);
    const hasScope = /(scope|objective|goal|outcome|success|kpi|metric)/i.test(
      allText,
    );
    const hasNFR =
      /(nfr|non[- ]?functional|performance|latency|throughput|availability|reliability|security|compliance|gdpr|hipaa)/i.test(
        allText,
      );
    const hasConstraints =
      /(constraint|assumption|risk|limitation|budget|timeline|deadline)/i.test(
        allText,
      );
    const hasInterface =
      /(\bui\b|ux|screen|page|api|endpoint|integration|webhook)/i.test(allText);
    const hasTesting = /(test|qa|acceptance\s*criteria|traceability)/i.test(
      allText,
    );
    const hasData =
      /(data\s*model|schema|database|storage|retention|index)/i.test(allText);

    // Q&A loop: assistant asked a question and user responded afterward
    let qaLoop = false;
    for (let i = msgs.length - 1; i >= 0; i--) {
      const m = msgs[i];
      if (m.role === "assistant" && /\?/.test(m.content || "")) {
        qaLoop = msgs
          .slice(i + 1)
          .some(
            (x) => x.role === "user" && (x.content || "").trim().length >= 20,
          );
        break;
      }
    }

    // Scoring
    let score = 0;
    const missing: string[] = [];
    // Clarity via SHALLs
    if (shalls.length >= 5) score += 25;
    else if (shalls.length >= 3) score += 20;
    else if (shalls.length >= 1) score += 10;
    else missing.push("clear requirements (SHALL)");
    // Coverage
    if (hasStakeholders) score += 15;
    else missing.push("stakeholders/users");
    if (hasScope) score += 15;
    else missing.push("scope/objectives");
    if (hasNFR) score += 10;
    else missing.push("NFRs (performance/security)");
    if (hasConstraints) score += 10;
    else missing.push("constraints/risks");
    if (hasInterface) score += 10;
    else missing.push("UI/API/integrations");
    if (hasTesting) score += 5;
    else missing.push("testing/acceptance");
    if (hasData) score += 5;
    else missing.push("data model/retention");
    // Conversation depth & detail
    if (userCount >= 2) score += 10;
    if (userCount >= 3) score += 10;
    if (totalChars >= 400) score += 10;
    // Q&A loop
    if (qaLoop) score += 10;

    if (score > 100) score = 100;
    // Encourage an actual back-and-forth: if no Q&A loop yet, cap readiness
    if (substantiveUserReplies < 2) {
      missing.push("additional user detail (two fuller replies)");
    }
    const ready = score >= 60 && substantiveUserReplies >= 2;
    const reason = ready
      ? `Ready (score ${score}).`
      : `Readiness ${score}%. Keep chatting to cover gaps.`;
    return { ready, reason, score, missing };
  }

  function quickPromptsFromMissing(
    missing: string[],
  ): { key: string; label: string; prompt: string }[] {
    const map: Record<string, { label: string; prompt: string }> = {
      "stakeholders/users": {
        label: "Stakeholders",
        prompt:
          "Stakeholders: Who are the primary users or stakeholders and what are their goals?",
      },
      "scope/objectives": {
        label: "Scope",
        prompt:
          "Scope & Objectives: What is in scope for the first release and what outcomes define success?",
      },
      "NFRs (performance/security)": {
        label: "NFRs",
        prompt:
          "NFRs: Any performance targets (latency/throughput), availability, or security/compliance needs?",
      },
      "constraints/risks": {
        label: "Constraints",
        prompt:
          "Constraints & Risks: Any budget, timeline, technical constraints, assumptions, or known risks?",
      },
      "UI/API/integrations": {
        label: "Interfaces",
        prompt:
          "Interfaces: Which screens, APIs, integrations, or webhooks are expected?",
      },
      "testing/acceptance": {
        label: "Testing",
        prompt:
          "Testing: What acceptance criteria or test scenarios would confirm success?",
      },
      "data model/retention": {
        label: "Data",
        prompt:
          "Data: What data is involved, any schema/storage considerations, or retention policies?",
      },
      "clear requirements (SHALL)": {
        label: "Requirements",
        prompt:
          'Requirements: Can you provide 2–3 specific requirements? Example: "The system SHALL allow users to reset passwords via email."',
      },
    };
    const dedup: string[] = [];
    const out: { key: string; label: string; prompt: string }[] = [];
    for (const k of missing) {
      if (map[k] && !dedup.includes(k)) {
        dedup.push(k);
        out.push({ key: k, ...map[k] });
      }
      if (out.length >= 4) break; // show up to 4 chips
    }
    return out;
  }

  function onExtract() {
    const msgs = current?.messages || [];
    const texts = msgs.map((m) => m.content);
    const found: string[] = [];
    for (const t of texts) {
      found.push(...extractShallFromText(t));
    }
    const seen = new Set<string>();
    const uniq: string[] = [];
    for (const r of found) {
      if (!seen.has(r)) {
        seen.add(r);
        uniq.push(r);
      }
    }
    setExtracted(uniq);
    const map: Record<string, boolean> = {};
    uniq.forEach((r) => (map[r] = true));
    setSelectedMap(map);
    setSyncNotice(
      uniq.length
        ? `Found ${uniq.length} candidate requirements.`
        : "No SHALL statements found in assistant messages.",
    );
  }

  async function onApplySelectedToContext() {
    const selected = extracted.filter((r) => selectedMap[r]);
    if (!selected.length) {
      setSyncNotice("Select at least one requirement to apply.");
      return;
    }
    try {
      setSyncing(true);
      setSyncNotice(null);
      // Fetch existing context
      const ctx = await getProjectContext(projectId);
      const data: any = ctx && ctx.data ? { ...ctx.data } : {};
      const answers: Record<string, string[]> = Array.isArray(data.answers)
        ? {}
        : data.answers || {};
      const currentReqs: string[] = Array.isArray(answers["Requirements"])
        ? answers["Requirements"]
        : [];
      const merged = currentReqs.slice();
      for (const r of selected) {
        if (!merged.includes(r)) merged.push(r);
      }
      const payload = {
        data: { ...data, answers: { ...answers, Requirements: merged } },
      } as any;
      const saved = await putProjectContext(projectId, payload);
      setSyncNotice(
        `Applied ${selected.length} requirement(s) to stored context.`,
      );
    } catch (e: any) {
      setSyncNotice(e?.message || String(e));
    } finally {
      setSyncing(false);
    }
  }

  const readyInfo = useMemo(() => {
    const msgs = current?.messages || [];
    const shalls = extractShallFromText(msgs.map((m) => m.content).join("\n"));
    return computeReadinessFromMessages(msgs as any, shalls);
  }, [current?.messages]);

  const readinessPercent = Math.round(readyInfo.score || 0);
  const readinessBadgeClass = readyInfo.ready
    ? "chat-shell__badge chat-shell__badge--ready"
    : "chat-shell__badge";
  const quickPrompts = Array.isArray(readyInfo.missing)
    ? quickPromptsFromMissing(readyInfo.missing)
    : [];

  useEffect(() => {
    if (toolsInitialized.current) return;
    const shouldOpen = !readyInfo.ready && (current?.messages?.length || 0) > 0;
    setToolsOpen(shouldOpen);
    toolsInitialized.current = true;
  }, [readyInfo.ready, current?.messages?.length]);

  return (
    <>
      <section
        className="chat-shell chat-shell--gpt"
        aria-label="Project Chat"
        role="region"
      >
        <header className="chat-shell__header">
          <div className="chat-shell__title">
            <span className="section-title">Chat</span>
            {notice && (
              <span className="chat-shell__notice" aria-live="polite">
                {notice}
              </span>
            )}
          </div>
          <div className="chat-shell__meta">
            <span className={readinessBadgeClass} title={readyInfo.reason}>
              Readiness {readinessPercent}%
            </span>
            {generating && (
              <span
                className="chat-shell__badge chat-shell__badge--progress"
                aria-live="polite"
              >
                Generating…
              </span>
            )}
          </div>
        </header>

        {(catalogLoading || catalogError || catalogIntents.length > 0) && (
          <div className="chat-shell__recipes" aria-live="polite">
            <div className="chat-shell__recipes-header">
              <strong>Switch focus</strong>
              <span className="muted">
                Choose another recipe to quickly steer this conversation.
              </span>
            </div>
            {catalogError && (
              <div className="chat-shell__recipes-status" role="alert">
                {catalogError}
              </div>
            )}
            <div className="chat-shell__recipes-chips">
              {catalogLoading && (
                <span className="chat-shell__recipes-chip" aria-busy="true">
                  Loading…
                </span>
              )}
              {catalogIntents.map((intent) => (
                <button
                  key={intent.intent_id}
                  type="button"
                  className="chat-shell__recipes-chip"
                  onClick={() => {
                    const msg = formatCatalogIntentPrompt(intent);
                    if (!msg) return;
                    setDraft(msg);
                    trackEvent("intent_prefill_selected", {
                      intentId: intent.intent_id,
                      title: intent.title,
                      group: intent.group,
                      source: "chat-panel",
                    });
                    requestAnimationFrame(autoResize);
                    requestAnimationFrame(() => inputRef.current?.focus());
                  }}
                >
                  <span aria-hidden="true">{intent.icon || "💡"}</span>
                  <span>{intent.title}</span>
                </button>
              ))}
            </div>
          </div>
        )}

        <div className="chat-shell__utility">
          <details
            className="chat-shell__drawer"
            open={capabilitiesOpen}
            onToggle={(event) => setCapabilitiesOpen(event.currentTarget.open)}
          >
            <summary className="chat-shell__summary">Chat capabilities & history</summary>
            <div className="chat-shell__drawer-body" style={{ display: "grid", gap: 12 }}>
              <div className="chat-shell__recipes" aria-live="polite">
                <div className="chat-shell__recipes-header">
                  <strong>Suggested starters</strong>
                  <span className="muted">Use a template to steer the assistant.</span>
                </div>
                {templatesError && (
                  <div className="chat-shell__recipes-status" role="alert">
                    {templatesError}
                  </div>
                )}
                <div className="chat-shell__recipes-chips">
                  {templatesLoading && (
                    <span className="chat-shell__recipes-chip" aria-busy="true">
                      Loading…
                    </span>
                  )}
                  {templates.map((template) => (
                    <button
                      key={template.template_id}
                      type="button"
                      className="chat-shell__recipes-chip"
                      onClick={() => onTemplateSelect(template)}
                    >
                      <span>{template.title}</span>
                    </button>
                  ))}
                  {!templatesLoading && !templatesError && templates.length === 0 && (
                    <span className="chat-shell__recipes-status">Templates coming soon.</span>
                  )}
                </div>
              </div>

              <form
                onSubmit={runSearch}
                style={{ display: "grid", gap: 8 }}
                aria-label="Search past chat messages"
              >
                <label style={{ display: "grid", gap: 4 }}>
                  <span className="muted">Search past chats</span>
                  <input
                    className="input"
                    value={searchQuery}
                    onChange={(event) => setSearchQuery(event.target.value)}
                    placeholder="Find sessions or answers"
                  />
                </label>
                <div
                  style={{
                    display: "flex",
                    gap: 8,
                    alignItems: "center",
                    flexWrap: "wrap",
                  }}
                >
                  <button className="btn" type="submit" disabled={searching}>
                    {searching ? "Searching…" : "Search"}
                  </button>
                  {searchError && (
                    <span className="error" role="alert">
                      {searchError}
                    </span>
                  )}
                  {searchResults.length > 0 && (
                    <span className="muted">{searchResults.length} result(s)</span>
                  )}
                </div>
              </form>

              {searchResults.length > 0 && (
                <ul
                  style={{
                    margin: 0,
                    padding: 0,
                    listStyle: "none",
                    display: "grid",
                    gap: 8,
                  }}
                >
                  {searchResults.map((hit) => (
                    <li
                      key={`${hit.session.session_id}-${hit.message.message_id}`}
                      style={{
                        border: "1px solid var(--border)",
                        borderRadius: 8,
                        padding: 12,
                        background: "var(--surface)",
                      }}
                    >
                      <div
                        style={{
                          display: "flex",
                          justifyContent: "space-between",
                          gap: 12,
                          alignItems: "flex-start",
                          flexWrap: "wrap",
                        }}
                      >
                        <div>
                          <strong>{hit.session.title}</strong>
                          <span className="muted" style={{ marginLeft: 8 }}>
                            {new Date(hit.message.created_at).toLocaleString()}
                          </span>
                        </div>
                        <button
                          className="btn"
                          type="button"
                          onClick={() => {
                            setSelected(hit.session.session_id);
                            void loadSession(hit.session.session_id);
                            setCapabilitiesOpen(false);
                          }}
                        >
                          Open chat
                        </button>
                      </div>
                      <p className="muted" style={{ marginTop: 8, whiteSpace: "pre-wrap" }}>
                        {hit.snippet}
                      </p>
                    </li>
                  ))}
                </ul>
              )}
            </div>
          </details>

          <details
            className="chat-shell__drawer chat-shell__drawer--compact"
            open={controlsOpen}
            onToggle={(event) => setControlsOpen(event.currentTarget.open)}
          >
            <summary className="chat-shell__summary">
              Conversation controls
            </summary>
            <div className="chat-toolbar">
              <label className="chat-toolbar__label">
                <span className="muted">New Chat Title</span>
                <input
                  className="input"
                  value={titleDraft}
                  onChange={(e) => setTitleDraft(e.target.value)}
                  placeholder="Refinement Chat"
                />
              </label>
              <div className="chat-toolbar__actions">
                <button className="btn" onClick={onNewSession} disabled={loading}>
                  {loading ? "Starting…" : "Start New Chat"}
                </button>
                <select
                  className="select"
                  value={selected || ""}
                  onChange={(e) => setSelected(e.target.value || null)}
                  aria-label="Select chat session"
                >
                  <option value="" disabled>
                    Choose a session…
                  </option>
                  {sessions.map((s) => (
                    <option key={s.session_id} value={s.session_id}>
                      {s.title} — {new Date(s.updated_at).toLocaleString()}
                    </option>
                  ))}
                </select>
                <select
                  className="select"
                  value={selectedModel}
                  onChange={(e) => {
                    const next = e.target.value;
                    setSelectedModel(next);
                    const choice = models.find(
                      (opt) => serializeModelKey(opt) === next,
                    );
                    if (choice) {
                      setModelPreference(choice.provider, choice.model);
                    } else if (next.startsWith("adaptive")) {
                      setModelPreference("adaptive", "auto");
                    }
                  }}
                  aria-label="Select model"
                  disabled={modelLoading || models.length === 0}
                >
                  {models.map((opt) => {
                    const key = serializeModelKey(opt);
                    return (
                      <option
                        key={key}
                        value={key}
                        disabled={!opt.available && !opt.adaptive}
                      >
                        {opt.label}
                        {opt.available ? "" : " (unavailable)"}
                      </option>
                    );
                  })}
                </select>
                {modelError && (
                  <span className="chat-shell__recipes-status" role="alert">
                    {modelError}
                  </span>
                )}
              </div>
            </div>
          </details>

          <details
            className="chat-shell__drawer"
            open={toolsOpen}
            onToggle={(event) => setToolsOpen(event.currentTarget.open)}
          >
            <summary className="chat-shell__summary">
              Readiness & document tools
            </summary>
            <div className="chat-shell__drawer-body">
              <div className="chat-readiness">
                <div className="chat-readiness__header">
                  <strong>Readiness to Generate</strong>
                  <span className="muted">{readinessPercent}%</span>
                </div>
                <div className="chat-readiness__bar" aria-label="Readiness progress">
                  <div
                    style={{
                      width: `${Math.max(0, Math.min(100, readinessPercent))}%`,
                    }}
                  />
                </div>
                {!readyInfo.ready && (
                  <p className="chat-readiness__hint">
                    {readyInfo.reason}{" "}
                    {Array.isArray(readyInfo.missing) && readyInfo.missing.length
                      ? `Hint: add ${readyInfo.missing.slice(0, 3).join(", ")}.`
                      : ""}
                  </p>
                )}
                {quickPrompts.length > 0 && (
                  <div className="chat-readiness__chips">
                    {quickPrompts.map((p) => (
                      <button
                        key={p.key}
                        type="button"
                        className="badge"
                        title={p.prompt}
                        onClick={() => {
                          setDraft((prev) =>
                            prev && prev.trim()
                              ? `${prev.trim()}\n${p.prompt}`
                              : p.prompt,
                          );
                          requestAnimationFrame(() => inputRef.current?.focus());
                        }}
                      >
                        + {p.label}
                      </button>
                    ))}
                  </div>
                )}
              </div>

              <div className="chat-shell__actions">
                <strong>Review & Apply</strong>
                {onRegenerateRequested && (
                  <button
                    className="btn btn-primary"
                    onClick={applyAllAndGenerate}
                    disabled={generating || syncing || !readyInfo.ready}
                    aria-busy={generating || undefined}
                    title={readyInfo.ready ? undefined : readyInfo.reason}
                  >
                    {generating ? "Applying & Generating…" : "Apply & Generate"}
                  </button>
                )}
                {generating && (
                  <div className="chat-shell__progress" aria-live="polite">
                    <progress
                      aria-label="Generating documents"
                      max={1}
                      value={Math.max(0, Math.min(1, generationProgress))}
                    />
                    <span className="muted">Working on generation…</span>
                  </div>
                )}
                {generationStages.length > 0 && (
                  <ul className="generation-stages" aria-live="polite">
                    {generationStages.map((stage, idx) => (
                      <li key={`${stage}-${idx}`}>{stage}</li>
                    ))}
                  </ul>
                )}
                <label className="chat-shell__toggle">
                  <input
                    type="checkbox"
                    checked={autoGenerate}
                    onChange={(e) => setAutoGenerate(e.target.checked)}
                  />{" "}
                  Auto-apply & generate (when ready)
                </label>
                <details className="chat-shell__drawer-inner">
                  <summary>More tools</summary>
                  <div className="chat-shell__drawer-inner-body">
                    <button
                      className="btn"
                      onClick={onExtract}
                      disabled={!current || (current.messages?.length || 0) === 0}
                    >
                      Extract suggestions
                    </button>
                    <button
                      className="btn"
                      onClick={applyAllFromChat}
                      disabled={
                        syncing ||
                        !current ||
                        (current.messages?.length || 0) === 0
                      }
                    >
                      Apply all from chat
                    </button>
                    <button
                      className="btn"
                      onClick={onApplySelectedToContext}
                      disabled={syncing || extracted.length === 0}
                    >
                      {syncing ? "Applying…" : "Apply selected to Stored Context"}
                    </button>
                  </div>
                </details>
                {syncNotice && <span className="muted">{syncNotice}</span>}
              </div>

              {extracted.length > 0 && (
                <div className="chat-shell__extracted">
                  {extracted.map((r, i) => (
                    <label key={i}>
                      <input
                        type="checkbox"
                        checked={!!selectedMap[r]}
                        onChange={(e) =>
                          setSelectedMap((prev) => ({
                            ...prev,
                            [r]: e.target.checked,
                          }))
                        }
                      />
                      <span>{r}</span>
                    </label>
                  ))}
                </div>
              )}

              <p className="chat-shell__tip">
                Tip: Review the assistant’s suggested SHALL requirements and apply
                only the ones you approve. You can regenerate documents afterward.
              </p>
            </div>
          </details>

          {error && (
            <div className="chat-shell__alert" role="alert">
              {error}
            </div>
          )}
        </div>

        <div className="chat-shell__viewport">
          <div className="chat-shell__stream">
            {!current || (current.messages?.length || 0) === 0 ? (
              <div className="chat-shell__empty">
                <h2>Ready to capture the next idea?</h2>
                <p>
                  Share context about your initiative, requirements, or questions. Paste a
                  brief or select a prompt chip to get started quickly.
                </p>
              </div>
            ) : (
              <ul className="chat-thread">
                {current.messages.map((m) => (
                  <li
                    key={m.message_id}
                    className={`chat-thread__item chat-thread__item--${m.role}`}
                  >
                    <div
                      className={`msg ${
                        m.role === "user" ? "msg-user" : "msg-assistant"
                      }`}
                      aria-label={`${m.role} message`}
                    >
                      {m.content}
                      <div className={`msg-meta msg-meta--${m.role}`}>
                        {new Date(m.created_at).toLocaleTimeString()}
                      </div>
                    </div>
                  </li>
                ))}
                {assistantTyping && (
                  <li className="chat-thread__item chat-thread__item--assistant">
                    <div
                      className="msg msg-assistant"
                      aria-live="polite"
                      aria-label="assistant typing"
                    >
                      <div className="typing-indicator" role="status">
                        <span className="typing-dots">
                          <span />
                          <span />
                          <span />
                        </span>
                        <span>Assistant is typing…</span>
                      </div>
                    </div>
                  </li>
                )}
                <div ref={bottomRef} />
              </ul>
            )}
          </div>
        </div>

        <form className="chat-shell__composer" onSubmit={onSend}>
          <div className="chat-shell__composer-row">
            <textarea
              ref={inputRef}
              className="chat-shell__input"
              aria-label="Your message"
              placeholder="Send a message…"
              value={draft}
              onChange={(e) => {
                setDraft(e.target.value);
                autoResize();
              }}
              onKeyDown={(e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                  e.preventDefault();
                  onSend();
                }
              }}
              onFocus={() => {
                if (!selected && !sending) ensureSession().catch(() => {});
              }}
            />
            <button
              className="chat-shell__send"
              type="submit"
              disabled={sending || !draft.trim()}
              aria-busy={sending || undefined}
            >
              {sending ? "…" : "Send"}
            </button>
          </div>
          <p className="chat-shell__composer-hint">
            Press <kbd>Enter</kbd> to send • <kbd>Shift</kbd> + <kbd>Enter</kbd> for newline
          </p>
        </form>
      </section>

      <style jsx>{`
        .chat-shell {
          background: linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.94),
            rgba(238, 244, 255, 0.9)
          );
          border-radius: 24px;
          box-shadow:
            0 18px 34px rgba(26, 45, 92, 0.16),
            0 8px 18px rgba(26, 45, 92, 0.1);
          border: 1px solid rgba(120, 170, 255, 0.26);
          padding: clamp(18px, 3vw, 28px);
          display: grid;
          gap: clamp(18px, 2.4vw, 28px);
          color: #0b1220;
        }

        .chat-shell--floating {
          margin: 0 auto;
          max-width: min(960px, 100%);
        }

        .chat-shell__header {
          display: flex;
          flex-wrap: wrap;
          align-items: center;
          justify-content: space-between;
          gap: 14px;
        }

        .chat-shell__title {
          display: inline-flex;
          align-items: center;
          gap: 10px;
        }

        .chat-shell__notice {
          font-size: 13px;
          color: #2563eb;
        }

        .chat-shell__meta {
          display: inline-flex;
          align-items: center;
          gap: 8px;
        }

        .chat-shell__badge {
          display: inline-flex;
          align-items: center;
          gap: 6px;
          font-size: 12px;
          padding: 4px 10px;
          border-radius: 999px;
          background: rgba(37, 99, 235, 0.08);
          color: #1e3a8a;
          border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .chat-shell__badge--ready {
          background: rgba(14, 159, 110, 0.1);
          border-color: rgba(14, 159, 110, 0.18);
          color: #065f46;
        }

        .chat-shell__badge--progress {
          background: rgba(219, 234, 254, 0.8);
          border-color: rgba(147, 197, 253, 0.6);
          color: #1d4ed8;
        }

        .chat-shell__alert {
          padding: 12px 16px;
          border-radius: 14px;
          background: rgba(254, 242, 242, 0.82);
          border: 1px solid rgba(248, 113, 113, 0.48);
          color: #7f1d1d;
          font-size: 14px;
        }

        .chat-shell__drawer {
          border-radius: 18px;
          background: rgba(248, 250, 255, 0.78);
          border: 1px solid rgba(191, 219, 254, 0.42);
          padding: 12px 16px;
        }

        .chat-shell__drawer[open] {
          box-shadow: 0 10px 24px rgba(17, 24, 39, 0.12);
        }

        .chat-shell__drawer--compact {
          background: transparent;
          border: none;
          padding: 0;
        }

        .chat-shell__summary {
          list-style: none;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          display: inline-flex;
          align-items: center;
          gap: 8px;
          color: #1e3a8a;
        }

        .chat-shell__summary::before {
          content: "";
          width: 8px;
          height: 8px;
          border-radius: 50%;
          background: currentColor;
          opacity: 0.35;
          margin-right: 6px;
        }

        :global(.chat-shell__drawer summary:focus),
        :global(.chat-shell__drawer-inner summary:focus),
        .chat-shell__summary:focus,
        .chat-shell__send:focus {
          outline: 2px solid rgba(79, 70, 229, 0.45);
          outline-offset: 2px;
        }

        .chat-shell__drawer-body {
          display: grid;
          gap: 16px;
          margin-top: 12px;
        }

        .chat-shell__drawer-inner {
          border: 1px dashed rgba(148, 163, 184, 0.38);
          border-radius: 14px;
          padding: 8px 12px;
        }

        .chat-shell__drawer-inner summary {
          cursor: pointer;
          font-size: 13px;
          color: #1d4ed8;
        }

        .chat-shell__drawer-inner-body {
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
          margin-top: 10px;
        }

        .chat-toolbar {
          display: flex;
          flex-wrap: wrap;
          gap: 12px;
          align-items: center;
          padding: 12px 16px;
          border-radius: 18px;
          background: rgba(241, 245, 255, 0.85);
          border: 1px solid rgba(191, 219, 254, 0.45);
        }

        .chat-toolbar__label {
          display: inline-flex;
          align-items: center;
          gap: 8px;
          min-width: 220px;
        }

        .chat-shell__body {
          background: rgba(255, 255, 255, 0.94);
          border-radius: 22px;
          border: 1px solid rgba(203, 213, 225, 0.55);
          padding: clamp(14px, 2vw, 20px);
          height: clamp(420px, 52vh, 560px);
          overflow-y: auto;
        }

        .chat-shell__empty {
          text-align: center;
          font-size: 14px;
          padding: 40px 24px;
        }

        .chat-thread {
          list-style: none;
          margin: 0;
          padding: 0;
          display: flex;
          flex-direction: column;
          gap: 12px;
        }

        .chat-thread__item {
          display: flex;
          width: 100%;
        }

        .chat-thread__item--user {
          justify-content: flex-end;
        }

        .chat-thread__item--assistant {
          justify-content: flex-start;
        }

        .msg {
          max-width: min(680px, 75%);
          padding: 12px 16px;
          border-radius: 18px;
          border: 1px solid rgba(203, 213, 225, 0.5);
          background: rgba(249, 250, 255, 0.9);
          box-shadow: 0 10px 22px rgba(148, 163, 184, 0.22);
          white-space: pre-wrap;
          font-size: 14px;
          line-height: 1.55;
          color: #0f172a !important;
          backdrop-filter: blur(14px);
        }

        .msg-user {
          background: linear-gradient(
            135deg,
            rgba(79, 70, 229, 0.18),
            rgba(59, 130, 246, 0.22)
          );
          border-color: rgba(99, 102, 241, 0.3);
        }

        .msg-assistant {
          background: rgba(255, 255, 255, 0.95);
          border-color: rgba(148, 163, 184, 0.32);
        }

        .msg-meta {
          font-size: 11px;
          color: rgba(100, 116, 139, 0.8);
          margin-top: 6px;
        }

        .msg-meta--assistant {
          text-align: left;
        }

        .msg-meta--user {
          text-align: right;
        }

        .chat-shell__composer {
          position: sticky;
          bottom: -12px;
          display: flex;
          align-items: flex-end;
          gap: 12px;
          padding: 14px 16px;
          border-radius: 18px;
          background: rgba(248, 250, 255, 0.96);
          border: 1px solid rgba(191, 219, 254, 0.5);
          box-shadow: 0 12px 28px rgba(148, 163, 184, 0.22);
        }

        .chat-shell__composer :global(.chat-input) {
          flex: 1 1 auto;
          min-height: 96px;
          resize: none;
          border-radius: 14px;
          border: 1px solid rgba(191, 219, 254, 0.6);
          background: rgba(255, 255, 255, 0.98);
        }

        .chat-shell__send {
          min-width: 110px;
          height: 42px;
        }

        .chat-shell__actions {
          display: grid;
          gap: 10px;
          align-items: flex-start;
          justify-items: flex-start;
        }

        .chat-shell__progress {
          display: inline-flex;
          align-items: center;
          gap: 8px;
        }

        .chat-shell__toggle {
          display: inline-flex;
          align-items: center;
          gap: 8px;
          font-size: 13px;
          color: #1f2937;
        }

        .chat-shell__extracted {
          display: grid;
          gap: 8px;
          max-height: 180px;
          overflow-y: auto;
          padding: 10px 12px;
          border-radius: 14px;
          border: 1px solid rgba(203, 213, 225, 0.4);
          background: rgba(255, 255, 255, 0.82);
        }

        .chat-shell__extracted label {
          display: flex;
          align-items: flex-start;
          gap: 8px;
          font-size: 13px;
          color: #111827;
        }

        .chat-shell__tip {
          font-size: 12px;
          color: rgba(71, 85, 105, 0.9);
        }

        .chat-shell__tip--footer {
          text-align: center;
          margin-top: -4px;
        }

        .chat-readiness {
          border-radius: 18px;
          border: 1px solid rgba(191, 219, 254, 0.48);
          padding: 14px 16px;
          background: rgba(240, 249, 255, 0.85);
          display: grid;
          gap: 10px;
        }

        .chat-readiness__header {
          display: flex;
          align-items: center;
          justify-content: space-between;
          gap: 8px;
        }

        .chat-readiness__bar {
          width: 100%;
          height: 8px;
          border-radius: 999px;
          background: rgba(191, 219, 254, 0.6);
          overflow: hidden;
        }

        .chat-readiness__bar > div {
          height: 100%;
          background: linear-gradient(
            90deg,
            rgba(59, 130, 246, 0.85),
            rgba(99, 102, 241, 0.9)
          );
          transition: width 0.3s ease;
        }

        .chat-readiness__hint {
          margin: 0;
          font-size: 13px;
          color: rgba(71, 85, 105, 0.92);
        }

        .chat-readiness__chips {
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
        }

        @media (max-width: 768px) {
          .chat-shell {
            border-radius: 20px;
            padding: 18px;
            gap: 18px;
          }

          .chat-shell__composer {
            flex-direction: column;
            align-items: stretch;
          }

          .chat-shell__send {
            width: 100%;
          }

          .chat-thread__item {
            justify-content: flex-start;
          }

          .msg {
            max-width: 100%;
          }
        }
      `}</style>
    </>
  );
}
